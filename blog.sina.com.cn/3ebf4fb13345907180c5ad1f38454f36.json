{"title":{"firstSourceText":"<h2 id=\"t_58ae76e80100kx1m\" class=\"titName SG_txta\">[原创]一句话解释数据结构</h2>"},"content":{"firstSourceText":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent   \">\n  &nbsp;\n <wbr>&nbsp;\n <wbr> 供自己复习用。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> KMP:预先计算失配后跳跃长度。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 线索化二叉树：将遍历前驱后继存为指针。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 二叉搜索树：中序遍历是递增的二叉树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 最优二叉搜索树：搜索长度期望最小的二叉搜索树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 哈夫曼树：长度x权值最小的树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 哈夫曼树生成：选择最小的树枝放到最下面。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> AVL树：高度平衡的二叉搜索树（左右子树高度差&lt;=1）。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 最小（大）堆：越往上越小（大）的完全二叉树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> FilterDown(FilterUp)：向下（向上）调整一路分支。logn\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 生成树：包含图的所有顶点的树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 最小生成树：权值最小的生成树。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> Kruskal算法：总是用最小权值的边一步步连通所有顶点。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> Prim算法：每次都寻找最小并且有价值边（能连接2个连通分量）的贪婪算法。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> Dijstra算法：看最短的边，选最短的路。O(n^2)\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> Bellman Ford算法：以边数划分状态来做动态规划。O(n^2)\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> Floyd算法：将邻接矩阵不断增加节点并更新最终变为最短路径矩阵。O(n^3)\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 直接插入排序：依此将元素插到前面有序部分。比较 (n^2)/2 移动 (n^2)/2 O(n^2) 稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 折半插入排序：折半查找插入位置。比较 O(nlogn) 移动 O(n^2) 稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 链表插入排序：使用链表插入后无需移动（但是难以使用折半查找）。 查找 (n^2)/2 O(n^2) 稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 希尔排序：隔n个排一下，直到n为1。n^1.25~1.6 n^1.25 不稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 冒泡排序：两两比较交换，直到没得换（改进）。 O(n^2) 稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 快速排序：大于n的在右小于n的在左，递归。 O(nlogn) 不稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 直接选择排序：每次选择一个最小的放到最前。O(n^2) 不稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 锦标赛排序：胜者树决定最小值。O(nlogn) 不稳定\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 堆排序：用堆排序。O(nlogn) 不稳定 占用内存多\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 归并排序：分成k份分别排序然后合并。O(nlongn) 稳定 占用内存多\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 基数排序：从低到高逐位排序。 O(d(n+radix))\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> k路平衡归并：将k个外存中的段归并。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr> 败者树：父节点保留失败者，送出最终胜利者。（对比胜者树，节点信息量更大，空间开销小）\n <br> \n</div>"},"date":{"firstSourceText":"2010-08-31 18:48:53"}}
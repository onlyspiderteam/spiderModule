{"title":{"firstSourceText":"<h2 id=\"t_58ae76e80100m352\" class=\"titName SG_txta\">Java源码研究日记--HashMap与HashTable</h2>"},"content":{"firstSourceText":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent   \">\n  &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 面试时经常问到一个问题：HashMap与HashTable有什么区别？一般回答是：HashTable实现了同步，HashMap没有。那么何为实现了同步？这需要先从Java同步机制讲起。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 我们知道，Java synchronized修饰符有几种用法：\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 一、对类的静态方法加synchronized，表示对这个类进行加锁，该类的任何静态synchronized方法都必须等待该方法执行结束。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 二、对对象的方法加synchronized，表示对这个对象加锁，该对象的任何synchronized方法都必须等待该方法执行结束。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 三、对语句块加锁，后跟对象，则对该对象进行的synchronized方法/synchronized语句块都必须等待该语句块执行结束。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> HashMap是线程不安全的，假设有多个线程使用同一个HashMap，并且没有显式的对这个对象加锁（如：用方法二），那么对HashMap的访问顺序将变得不可预知。而HashTable对所有public方法都加上了synchronized修饰，所以在多线程访问HashTable时，他们仍会互斥访问。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 但是Vector和HashTable现在已经过时了。现在的方式是：使用java.util.Collections类的synchronizedMap/synchronizedList/synchronizedSet方法。这个方法将Map装饰成一个新的Collection类，这个类的所有方法都是同步的。它的实现方法如下：\n <br> public boolean containsKey(Object key) {\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> synchronized(mutex) {return m.containsKey(key);}\n <br> }\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 这是一个典型的装饰器模式。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 面试的时候提到了一个有趣的问题：如果一个对象object引用了集合对象list中的某个元素，那么即使对list加锁，我仍可以通过改变object的值改变整个list的构成。经过测试，这个现象是存在的，并且无法通过synchronized修饰来避免。因为：Java同步的方法，是对整个对象的访问加锁，但是不会对对象的字段所引用的对象传递加锁。举例说明，HashMap中通过Entry[] table数组存放Entry，如果我用e1=table[0]，那么显然我对HashMap加锁之后，我仍可修改e1的值。这其实是一个并发的隐患。\n <br> &nbsp;\n <wbr>&nbsp;\n <wbr>&nbsp;\n <wbr> 其实从实现上来说，HashMap比HashTable性能更好。如：HashMap的capacity只会取2^n，用x&amp;capacity-1代替取模。\n <br> \n</div>"},"date":{"firstSourceText":"2010-10-31 11:02:06"}}